#pragma once

#ifndef _PROP_CLASS_
#define _PROP_CLASS_

#include "Extras/OVR_Math.h"
#include "Object3D.class"
#include "Shaderfill.class"
#include "VertexBuffer.class"
#include "IndexBuffer.class"


class Prop: public Object3D
{
    // Constructor for props being built at construction time
    public: Matrix4f        matrix;
    public: vector<Vertex>  Vertices;
    public: vector<GLushort> Indices;
    public: ShaderFill    * Fill;
    public: VertexBuffer  * vertexBuffer = nullptr;
    public: IndexBuffer   * indexBuffer = nullptr;

        // Blank Constructor
    public:	Prop():
        matrix(),
        vertexBuffer(nullptr),
        indexBuffer(nullptr) {}

    // Blank Constructor + Position and Shader
    public:	Prop(Vector3f pos, ShaderFill * fill) :
		    matrix(),
		    Fill(fill),
		    vertexBuffer(nullptr),
		    indexBuffer(nullptr)
	    {
        position = pos;
        }

    public:	~Prop()
	    {
		    FreeBuffers();
	    }

    public:	Matrix4f& GetMatrix()
	    {
		    matrix = Matrix4f(rotation);
		    matrix = Matrix4f::Translation(position) * matrix;
		    return matrix;
	    }

    public:	void AddVertex(const Vertex& v) {Vertices.push_back( v ); }
    public:	void AddIndex(GLushort a) { Indices.push_back( a ); }
    public:	void AddVertexes(vector<Vertex> vertices)
    {
	    vector<GLushort> frontFace;
	    for (auto cur = vertices.begin(); cur != vertices.end(); ++cur)
		    AddVertex( *cur );
    }

    public:	void AddIndexes(vector<GLushort> indices)
    {
	    for (auto cur = indices.begin(); cur != indices.end(); ++cur)
		    AddIndex(*cur);
    }
		
    public:	void AllocateBuffers()
    {
        vertexBuffer = new VertexBuffer(Vertices.data(), Vertices.size() * sizeof(Vertex));
	    indexBuffer = new IndexBuffer(Indices.data(), Indices.size() * sizeof(GLushort));
    }

    public:	void FreeBuffers()
	    {
		    if ( vertexBuffer != nullptr ) { delete vertexBuffer; vertexBuffer = nullptr; }
            if (indexBuffer != nullptr) { delete indexBuffer; indexBuffer = nullptr; }
	    }

    public:	void AddSolidColorBox(float x1, float y1, float z1, float x2, float y2, float z2, DWORD c)
	    {
		    Vector3f Vert[][2] =
		    {
			    Vector3f(x1, y2, z1), Vector3f(z1, x1), Vector3f(x2, y2, z1), Vector3f(z1, x2),
			    Vector3f(x2, y2, z2), Vector3f(z2, x2), Vector3f(x1, y2, z2), Vector3f(z2, x1),

			    Vector3f(x1, y1, z1), Vector3f(z1, x1), Vector3f(x2, y1, z1), Vector3f(z1, x2),
			    Vector3f(x2, y1, z2), Vector3f(z2, x2), Vector3f(x1, y1, z2), Vector3f(z2, x1),

			    Vector3f(x1, y1, z2), Vector3f(z2, y1), Vector3f(x1, y1, z1), Vector3f(z1, y1),
			    Vector3f(x1, y2, z1), Vector3f(z1, y2), Vector3f(x1, y2, z2), Vector3f(z2, y2),

			    Vector3f(x2, y1, z2), Vector3f(z2, y1), Vector3f(x2, y1, z1), Vector3f(z1, y1),
			    Vector3f(x2, y2, z1), Vector3f(z1, y2), Vector3f(x2, y2, z2), Vector3f(z2, y2),

			    Vector3f(x1, y1, z1), Vector3f(x1, y1), Vector3f(x2, y1, z1), Vector3f(x2, y1),
			    Vector3f(x2, y2, z1), Vector3f(x2, y2), Vector3f(x1, y2, z1), Vector3f(x1, y2),

			    Vector3f(x1, y1, z2), Vector3f(x1, y1), Vector3f(x2, y1, z2), Vector3f(x2, y1),
			    Vector3f(x2, y2, z2), Vector3f(x2, y2), Vector3f(x1, y2, z2), Vector3f(x1, y2)
		    };

		    GLushort CubeIndices[] =
		    {
			    0, 1, 3, 3, 1, 2,
			    5, 4, 6, 6, 4, 7,
			    8, 9, 11, 11, 9, 10,
			    13, 12, 14, 14, 12, 15,
			    16, 17, 19, 19, 17, 18,
			    21, 20, 22, 22, 20, 23
		    };

		    for (int i = 0; i < sizeof(CubeIndices) / sizeof(CubeIndices[0]); ++i)
			    AddIndex(CubeIndices[i] + GLushort( Vertices.size() ));

		    // Generate a quad for each box face
		    for (int v = 0; v < 6 * 4; v++)
		    {
			    // Make vertices, with some token lighting
			    Vertex vvv; vvv.Pos = Vert[v][0]; vvv.U = Vert[v][1].x; vvv.V = Vert[v][1].y;
			    float dist1 = (vvv.Pos - Vector3f(-2, 4, -2)).Length();
			    float dist2 = (vvv.Pos - Vector3f(3, 4, -3)).Length();
			    float dist3 = (vvv.Pos - Vector3f(-4, 3, 25)).Length();
			    int   bri = rand() % 160;
			    float B = ((c >> 16) & 0xff) * (bri + 192.0f * (0.65f + 8 / dist1 + 1 / dist2 + 4 / dist3)) / 255.0f;
			    float G = ((c >> 8) & 0xff) * (bri + 192.0f * (0.65f + 8 / dist1 + 1 / dist2 + 4 / dist3)) / 255.0f;
			    float R = ((c >> 0) & 0xff) * (bri + 192.0f * (0.65f + 8 / dist1 + 1 / dist2 + 4 / dist3)) / 255.0f;
			    vvv.C = (c & 0xff000000) +
				    ((R > 255 ? 255 : DWORD(R)) << 16) +
				    ((G > 255 ? 255 : DWORD(G)) << 8) +
				    (B > 255 ? 255 : DWORD(B));
			    AddVertex(vvv);
		    }
	    }

    public:	void Render(Matrix4f view, Matrix4f proj)
	    {
		    Matrix4f combined = proj * view * GetMatrix();

		    glUseProgram(Fill->program);
		    glUniform1i(glGetUniformLocation(Fill->program, "Texture0"), 0);
		    glUniformMatrix4fv(glGetUniformLocation(Fill->program, "matWVP"), 1, GL_TRUE, (FLOAT*)&combined);

		    glActiveTexture(GL_TEXTURE0);

		    if(Fill->texture != nullptr )
			    glBindTexture(GL_TEXTURE_2D, Fill->texture->texId);

		    glBindBuffer(GL_ARRAY_BUFFER,  vertexBuffer->buffer);
		    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indexBuffer->buffer);

		    GLuint posLoc = glGetAttribLocation(Fill->program, "Position");
		    GLuint colorLoc = glGetAttribLocation(Fill->program, "Color");
		    GLuint uvLoc = glGetAttribLocation(Fill->program, "TexCoord");

		    glEnableVertexAttribArray(posLoc);
		    glEnableVertexAttribArray(colorLoc);
		    glEnableVertexAttribArray(uvLoc);

		    glVertexAttribPointer(posLoc, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)OVR_OFFSETOF(Vertex, Pos));
		    glVertexAttribPointer(colorLoc, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(Vertex), (void*)OVR_OFFSETOF(Vertex, C));
		    glVertexAttribPointer(uvLoc, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)OVR_OFFSETOF(Vertex, U));

		    glDrawElements(GL_TRIANGLES, Indices.size(), GL_UNSIGNED_SHORT, NULL);

		    glDisableVertexAttribArray(posLoc);
		    glDisableVertexAttribArray(colorLoc);
		    glDisableVertexAttribArray(uvLoc);

		    glBindBuffer(GL_ARRAY_BUFFER, 0);
		    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

		    glUseProgram(0);
	    }
};

#endif _PROP_CLASS_

